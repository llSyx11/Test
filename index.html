<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Environment</title>
    <style>
        * { margin: 0; padding: 0; }
        canvas { display: block; }
        #joystick-container, #right-joystick { 
            position: fixed; 
            bottom: 20px;
            width: 100px;
            height: 100px;
            z-index: 100;
            display: none;
        }
        #joystick-container { left: 20px; }
        #right-joystick { right: 20px; }
        .keyboard-controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            color: white;
            font-family: Arial;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            display: none;
        }
        #collisionToggle, #controlToggle, #musicToggle {
            position: fixed;
            padding: 10px;
            z-index: 1000;
            background: #444;
            color: red;
            border: 2px solid yellow;
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial;
            font-weight: bold;
        }
        #collisionToggle { top: 20px; right: 20px; }
        #controlToggle { top: 60px; right: 20px; }
        #musicToggle { top: 100px; right: 20px; }
    </style>
</head>
<body>
    <div class="keyboard-controls">W A S D + Mouse</div>
    <button id="collisionToggle">Show Collisions</button>
    <button id="controlToggle">Switch to Mobile</button>
    <button id="musicToggle">Pause Music</button>
    <div id="joystick-container"></div>
    <div id="right-joystick"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/midi.js/0.3.0/midi.min.js"></script>

    <script>
        // Конфигурация
        const PLAYER_HEIGHT = 0.5;
        const CAMERA_HEIGHT = 1.6;
        const GRAVITY_FORCE = 5;
        const JUMP_FORCE = 600;
        const COLLISION_DISTANCE = 0.1;
        const STEP_HEIGHT = 0.3;
        const MODEL_URLS = [
            'https://cdn.jsdelivr.net/gh/llSyx11/Test@main/001.glb',
            'https://llsyx11.github.io/Test/001.glb',
            'https://raw.githubusercontent.com/llSyx11/Test/main/001.glb'
        ];

        let scene, camera, renderer, model;
        let isMobileMode = false;
        let moveSpeed = 0.8;
        let clock = new THREE.Clock();
        let yaw = 0;
        let pitch = 0;
        let velocity = new THREE.Vector3();
        let collisionObjects = [];
        let rainParticles, isRaining = true;
        let isMusicPlaying = true;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = true;

        init();
        animate();

        function init() {
            // Инициализация сцены
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            // Камера
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, CAMERA_HEIGHT, 0);

            // Рендерер
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Освещение
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);
            
            const directional = new THREE.DirectionalLight(0xffffff, 0.8);
            directional.position.set(5, 5, 5);
            scene.add(directional);

            // Окружение
            createCollisionEnvironment();
            createSky();
            createTrees();
            createRain();

            // Загрузка модели
            loadModelWithRetry();

            // Управление
            setupControls();
            setupEventListeners();
            playBackgroundMusic();

            // Адаптация к мобильным устройствам
            if(/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                toggleControlMode(true);
            }
        }

        function createCollisionEnvironment() {
            // Пол (темно-зеленый)
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(400, 400),
                new THREE.MeshStandardMaterial({ color: 0x006400, roughness: 0.8 })
            );
            floor.rotation.x = -Math.PI/2;
            scene.add(floor);
            collisionObjects.push(floor);

            // Стены
            const wallGeometry = new THREE.BoxGeometry(400, 3, 0.5);
            [[0,1,-200,0], [0,1,200,Math.PI], [-200,1,0,Math.PI/2], [200,1,0,-Math.PI/2]]
                .forEach(([x,y,z,ry]) => {
                    const wall = new THREE.Mesh(wallGeometry, new THREE.MeshStandardMaterial({ color: 0x555555 }));
                    wall.position.set(x,y,z);
                    wall.rotation.y = ry;
                    scene.add(wall);
                    collisionObjects.push(wall);
                });
        }

        function createSky() {
            // Солнце
            const sun = new THREE.Mesh(
                new THREE.CircleGeometry(5, 32),
                new THREE.MeshBasicMaterial({ color: 0xFFFF00 })
            );
            sun.position.set(0, 50, -100);
            sun.rotation.x = Math.PI/2;
            scene.add(sun);

            // Облака
            for(let i=0; i<20; i++) createCloud();
        }

        function createCloud() {
            const cloud = new THREE.Group();
            for(let i=0; i<5; i++) {
                const part = new THREE.Mesh(
                    new THREE.BoxGeometry(2,0.5,2),
                    new THREE.MeshPhongMaterial({ color: 0x4682B4 })
                );
                part.position.set(Math.random()*4-2, Math.random()*1-0.5, Math.random()*4-2);
                cloud.add(part);
            }
            cloud.position.set(Math.random()*400-200, 30+Math.random()*20, Math.random()*400-200);
            scene.add(cloud);
        }

        function createTrees() {
            const trunkMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const crownMat = new THREE.MeshPhongMaterial({ color: 0x228B22 });
            
            for(let i=0; i<100; i++) {
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.4,2,8), trunkMat);
                const crown = new THREE.Mesh(new THREE.SphereGeometry(1.5,6,6), crownMat);
                trunk.position.set(Math.random()*400-200, 1, Math.random()*400-200);
                crown.position.copy(trunk.position);
                crown.position.y += 1.5;
                crown.userData.originalY = crown.position.y;
                scene.add(trunk);
                scene.add(crown);
            }
        }

        function createRain() {
            const rainGeo = new THREE.BufferGeometry();
            const positions = [];
            for(let i=0; i<5000; i++) {
                positions.push(
                    Math.random()*400-200,
                    Math.random()*100+50,
                    Math.random()*400-200
                );
            }
            rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            rainParticles = new THREE.Points(
                rainGeo,
                new THREE.PointsMaterial({ color: 0x1a1a8d, size: 0.1, transparent: true })
            );
            scene.add(rainParticles);
        }

        function loadModelWithRetry(urls = MODEL_URLS, index = 0) {
            new THREE.GLTFLoader().load(urls[index],
                gltf => {
                    model = gltf.scene;
                    model.scale.set(1, 1, 1);
                    model.position.set(0, 0, -5);
                    
                    model.traverse(child => {
                        if(child.isMesh) {
                            if(child.name.startsWith('collision_')) {
                                child.visible = false;
                                collisionObjects.push(child);
                            }
                            if(child.name.includes('window')) {
                                child.material = new THREE.MeshStandardMaterial({
                                    metalness: 0.9,
                                    roughness: 0.1,
                                    envMap: scene.background
                                });
                            }
                        }
                    });
                    
                    scene.add(model);
                },
                undefined,
                error => {
                    console.error(`Error loading model (attempt ${index+1}):`, error);
                    const nextIndex = (index + 1) % urls.length;
                    setTimeout(() => loadModelWithRetry(urls, nextIndex), 1000);
                }
            );
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Обновление камеры
            camera.rotation.set(pitch, yaw, 0, 'YXZ');
            velocity.y -= GRAVITY_FORCE * delta;

            // Движение
            const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
            const moveDirection = new THREE.Vector3();

            if(moveForward && !checkCollision(forward)) moveDirection.add(forward);
            if(moveBackward && !checkCollision(forward.clone().negate())) moveDirection.sub(forward);
            if(moveLeft && !checkCollision(right.clone().negate())) moveDirection.sub(right);
            if(moveRight && !checkCollision(right)) moveDirection.add(right);

            camera.position.add(moveDirection.normalize().multiplyScalar(moveSpeed * delta));
            camera.position.y += velocity.y * delta;

            // Проверка ступенек
            checkStepUp();

            // Ограничение высоты
            if(camera.position.y < CAMERA_HEIGHT - PLAYER_HEIGHT) {
                camera.position.y = CAMERA_HEIGHT - PLAYER_HEIGHT;
                velocity.y = 0;
                canJump = true;
            }

            // Анимация окружения
            animateTrees(time);
            if(isRaining) animateRain();

            renderer.render(scene, camera);
        }

        function checkCollision(direction) {
            const raycaster = new THREE.Raycaster(camera.position, direction.normalize());
            const hit = raycaster.intersectObjects(collisionObjects);
            return hit.length > 0 && hit[0].distance < COLLISION_DISTANCE;
        }

        function checkStepUp() {
            const downRay = new THREE.Raycaster(camera.position, new THREE.Vector3(0, -1, 0));
            const hit = downRay.intersectObjects(collisionObjects);
            if(hit.length > 0 && hit[0].distance < STEP_HEIGHT) {
                camera.position.y += STEP_HEIGHT - hit[0].distance;
            }
        }

        function animateTrees(time) {
            scene.traverse(child => {
                if(child.material?.color?.getHex() === 0x228B22) {
                    child.position.y = child.userData.originalY + Math.sin(time * 0.002) * 0.5;
                }
            });
        }

        function animateRain() {
            const positions = rainParticles.geometry.attributes.position.array;
            for(let i=1; i<positions.length; i+=3) {
                positions[i] -= 1;
                if(positions[i] < -10) positions[i] = Math.random()*50 + 50;
            }
            rainParticles.geometry.attributes.position.needsUpdate = true;
        }

        function playBackgroundMusic() {
            MIDI.loadPlugin({
                soundfontUrl: "https://cdn.jsdelivr.net/gh/gleitz/midi-js-soundfonts@gh-pages/FatBoy/",
                instrument: "acoustic_grand_piano",
                onsuccess: function() {
                    setInterval(() => {
                        if(isMusicPlaying) {
                            MIDI.chordOn(0, [60, 64, 67], 100, 0);
                            MIDI.chordOff(0, [60, 64, 67], 0.5);
                        }
                    }, 1000);
                }
            });
        }

        function setupControls() {
            if(isMobileMode) setupMobileControls();
            else setupDesktopControls();
        }

        function setupDesktopControls() {
            document.querySelector('.keyboard-controls').style.display = 'block';
            const canvas = renderer.domElement;

            canvas.addEventListener('click', () => {
                canvas.requestPointerLock();
            });

            document.addEventListener('pointerlockchange', () => {
                isLocked = !!document.pointerLockElement;
                if(isLocked) document.addEventListener('mousemove', updateRotation);
                else document.removeEventListener('mousemove', updateRotation);
            });

            function updateRotation(e) {
                yaw -= e.movementX * 0.002;
                pitch = THREE.MathUtils.clamp(pitch - e.movementY * 0.002, -Math.PI/2, Math.PI/2);
            }

            window.addEventListener('keydown', (e) => {
                switch(e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': 
                        if(canJump) {
                            velocity.y = JUMP_FORCE * clock.getDelta();
                            canJump = false; 
                        }
                        break;
                }
            });

            window.addEventListener('keyup', (e) => {
                switch(e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            });
        }

        function setupMobileControls() {
            document.getElementById('joystick-container').style.display = 'block';
            document.getElementById('right-joystick').style.display = 'block';

            const leftJoystick = nipplejs.create({
                zone: document.getElementById('joystick-container'),
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'white',
                size: 100
            });

            const rightJoystick = nipplejs.create({
                zone: document.getElementById('right-joystick'),
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'white',
                size: 100
            });

            leftJoystick.on('move', (evt, data) => {
                const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
                const move = right.multiplyScalar(data.vector.x * moveSpeed * 0.05)
                             .add(forward.multiplyScalar(data.vector.y * moveSpeed * 0.05));
                
                if(!checkCollision(move.clone().normalize())) {
                    camera.position.add(move);
                }
            });

            rightJoystick.on('move', (evt, data) => {
                yaw += data.vector.x * 0.05;
                pitch = THREE.MathUtils.clamp(pitch - data.vector.y * 0.05, -Math.PI/2, Math.PI/2);
            });
        }

        function setupEventListeners() {
            // Кнопки управления
            document.getElementById('collisionToggle').addEventListener('click', () => {
                collisionObjects.forEach(obj => {
                    if(obj.material) obj.material.visible = !obj.material.visible;
                });
                document.getElementById('collisionToggle').textContent = 
                    collisionObjects[0].material.visible ? "Hide Collisions" : "Show Collisions";
            });

            document.getElementById('controlToggle').addEventListener('click', () => {
                isMobileMode = !isMobileMode;
                toggleControlMode(isMobileMode);
            });

            document.getElementById('musicToggle').addEventListener('click', () => {
                isMusicPlaying = !isMusicPlaying;
                document.getElementById('musicToggle').textContent = 
                    isMusicPlaying ? "Pause Music" : "Play Music";
            });

            // Ресайз окна
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function toggleControlMode(mobile) {
            // Очистка предыдущих контролов
            document.querySelector('.keyboard-controls').style.display = mobile ? 'none' : 'block';
            document.getElementById('joystick-container').style.display = mobile ? 'block' : 'none';
            document.getElementById('right-joystick').style.display = mobile ? 'block' : 'none';
            document.getElementById('controlToggle').textContent = mobile ? "Switch to Desktop" : "Switch to Mobile";
            
            // Переинициализация управления
            setupControls();
        }
    </script>
</body>
</html>
